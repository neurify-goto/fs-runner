## はじめに

このドキュメントでは、事前に作成された**指示書（instruction_json）**に基づいて、Webサイトのお問い合わせフォームに対し、指定されたデータを入力送信するための、**GAS トリガー + GitHub Actions ワークフロー**による自動化システムの網羅的なアルゴリズムを自然言語で記述します。

**実行アーキテクチャ**: Google Apps Script (GAS) がスプレッドシート連携によりアクティブなターゲティング設定を確認し、定期的に GitHub Actions ワークフローを `repository_dispatch` でトリガーする。ワークフロー内で処理対象企業を10件ずつ抽出・処理し、GitHub Actions側で営業時間・送信数制限を判定して連続ループ実行する分散処理システム。

あくまで処理フローを自然言語で定義する文書であるため、システム要件や実装計画、運用方針等については基本的に記述しません。

## 関連ファイル
- **ワークフロー**: `.github/workflows/form-sender.yml`
- **実行ファイル**: `src/form_sender_worker.py`
- **GAS制御システム**: `gas/form-sender/Code.gs`, `gas/form-sender/SpreadsheetClient.gs`, `gas/form-sender/GitHubClient.gs`

## 1. システム概要と実行仕様

GAS トリガー + GitHub Actions ワークフローによるフォーム送信システムの実行方法、データベース構成、および制御システムの仕様について説明します。

### 1.1. 実行アーキテクチャ仕様

#### **1.1.1. システム全体構成**

**GAS制御システム** → **GitHub Actions ワークフロー**

**トリガーフロー**:
1. **GAS定期実行**: 毎日決まった時間帯に起動
2. **アクティブ判定**: targeting-id ごとのアクティブ状態を確認
3. **repository_dispatch**: アクティブな targeting-id とスプレッドシート設定データを GitHub Actions ワークフローにトリガー
4. **連続ループ実行**: 営業時間等の制限を判定した上で、実行可能かどうかを判定した上で、ワークフロー内で処理対象を10件ずつ抽出・処理
5. **結果記録**: GitHub Actions内で各処理ループごとに Supabase に結果を直接保存

#### **1.1.2. GitHub Actions ワークフロー仕様**

- **ワークフローファイル**: `.github/workflows/form-sender.yml`
- **トリガータイプ**: `repository_dispatch` (イベントタイプ: `form_sender_task`)
- **実行ファイル**: `src/form_sender_worker.py`

**処理単位**: 1つのワークフロー実行につき1つのターゲティング設定を処理（複数のターゲティングがアクティブな場合は、それぞれ独立したワークフローが並行実行される）

**client_payload パラメータ**:
- `targeting_id`: ターゲティング設定ID（1以上の整数、必須）
- `client_config`: スプレッドシートから取得したクライアント設定データ（JSON形式、GASから渡される）

**実行環境**:
- **OS**: ubuntu-latest
- **Python**: 3.11
- **処理時間制御**: 開始から5時間経過で新規処理停止
- **ブラウザ**: Playwright Chromium

**連続処理仕様**:
- **処理単位**: 10件ずつの企業を抽出・処理
- **ループ制御**: 営業時間・1日送信数制限内で連続実行
- **時間制限**: 開始から5時間経過時点で新規処理対象取得ループに進まない
- **終了条件**: 処理対象企業がない場合、または5時間制限到達時

### 1.2. データベース構成仕様

**アーキテクチャ**: GAS（スプレッドシート専用）+ GitHub Actions（Supabase専用）の完全分離構成

#### **1.2.1. スプレッドシート `client`シート（GAS担当）**

**役割**: フォーム営業代行サービスのクライアント情報とターゲティング設定を管理
- **フォーム入力用情報**: 送信者情報、企業情報、連絡先等

**データアクセスパターン**:
- **読み取り**: GASがスプレッドシートから設定を読み取り、GitHub Actionsに渡す
- **管理**: 手動でのスプレッドシート編集による設定変更
- **書き込み**: GASおよびGitHub Actionsの処理フロー内では書き込みなし

#### **1.2.2. スプレッドシート `targeting`シート（GAS担当）**

**役割**: フォーム営業代行サービスのクライアント情報とターゲティング設定を管理
- **フォーム送信制御情報情報**: 送信対象抽出条件、制限設定、営業時間等
- **アクティブ状態管理**: targeting-id ごとの有効/無効制御

**データアクセスパターン**:
- **読み取り**: GASがスプレッドシートから設定を読み取り、GitHub Actionsに渡す
- **管理**: 手動でのスプレッドシート編集による設定変更
- **書き込み**: GASおよびGitHub Actionsの処理フロー内では書き込みなし

#### **1.2.3. Supabase `companies`テーブル（GitHub Actions担当）**

**役割**: フォーム送信先企業の個別情報を管理
- 企業基本情報（社名、フォームURL等）
- フォーム入力指示書（instruction_json）
- 指示書妥当性フラグ（instruction_valid）

**データアクセスパターン**:
- **読み取り**: GitHub Actionsが処理対象企業の抽出、フォーム送信指示書の取得
- **書き込み**: GitHub Actionsが`instruction_valid`フラグの更新（送信結果に基づく品質管理）

#### **1.2.4. Supabase `submissions`テーブル（GitHub Actions担当）**

**役割**: フォーム送信結果の履歴管理
- 送信成功・失敗の記録
- エラー分類とトラッキング
- 重複送信回避のための履歴

**データアクセスパターン**:
- **書き込み**: GitHub Actionsが送信結果の記録（成功・失敗両方）
- **読み取り**: GitHub Actionsが重複送信回避、日次送信数カウント

#### **1.2.5. DBアクセス機構**

**アーキテクチャ分離によるDBアクセス**: GitHub Actions が Supabase にアクセス。GAS は Supabase に一切アクセスせず、スプレッドシートの読み取りと GitHub Actions のトリガーのみを担当。

**連続処理でのDB アクセス考慮事項**:
- **処理時間制御**: 5時間制限を考慮した長時間安定接続の維持
- **リソース管理**: 長時間実行による接続プールの効率的管理と定期的な接続チェック
- **トランザクション制御**: 10件ごとの処理結果をまとめてコミットし、処理効率と障害時の影響範囲を最適化
- **接続安定性**: 長時間実行中のDB接続断絶に対する自動再接続とリトライ機構

### 1.3. クライアントデータ取得システム

#### **1.3.1. アクティブターゲティング向けスプレッドシートデータ抽出フロー**

GAS定期実行時に、targetingシートのアクティブ状態（`active=TRUE`）に基づいて、該当するクライアントデータを取得します。

**データ取得の流れ**:
1. **スプレッドシート接続**: GAS側でスプレッドシートに接続
2. **アクティブターゲティング検索**: targetingシートで `active=TRUE` のレコードをすべて検索
3. **各アクティブレコードに対して個別に以下を実行**:
   - **client_id取得**: 該当のtargetingレコードからclient_idを取得
   - **クライアントデータ取得**: clientシートからclient_idに対応するクライアント情報を取得
   - **データ結合**: targetingデータとclientデータを結合（project_nameは除外）
   - **個別ワークフロートリガー**: 1つのtargeting用に独立した `repository_dispatch` を実行し、専用のGitHub Actionsワークフローを起動

**スプレッドシート構成例**:

**targetingシート**:
| active | id | client_id | description | subject | message | targeting_sql | ng_companies | max_daily_sends | send_start_time | send_end_time | send_days_of_week |
|--------|----|-----------|-----------|---------|---------|--------------|--------------|-----------------|-----------------|--------------|--------------------|
| TRUE | 1 | 1 | IT企業向け新規営業 | お問い合わせの件 | お世話になっております。... | WHERE... | 除外企業リスト | 100 | 09:00 | 18:00 | [0,1,2,3,4] |

**clientシート**:
| id | project_name | company_name | company_name_kana | form_sender_name | last_name | first_name | last_name_kana | first_name_kana | last_name_hiragana | first_name_hiragana | position | department | gender | email_1 | email_2 | website_url | postal_code_1 | postal_code_2 | address_1 | address_2 | address_3 | address_4 | address_5 | phone_1 | phone_2 | phone_3 |
|----|--------------|--------------|-------------------|------------------|-----------|------------|----------------|-----------------|--------------------|--------------------|----------|------------|--------|---------|---------|-------------|---------------|---------------|-----------|-----------|-----------|-----------|-----------|---------|---------|---------|
| 1 | サンプルプロジェクト | 株式会社サンプル | カブシキガイシャサンプル | 田中太郎 | 田中 | 太郎 | タナカ | タロウ | たなか | たろう | 営業部長 | 営業部 | male | tanaka | sample.com | https://sample.co.jp | 100 | 0001 | 東京都 | 千代田区 | 神田 | 1-1-1 | サンプルビル5F | 03 | 1234 | 5678 |

#### **1.3.2. プレースホルダ変数システムとの連携**

取得したスプレッドシートデータは、既存の指示書システム（`InstructionTemplateProcessor`）で使用されるプレースホルダ変数に対応します。

**基本クライアント情報の対応**（clientシートから取得）:
- `{client.company_name}` ← clientシート `company_name` カラム
- `{client.company_name_kana}` ← clientシート `company_name_kana` カラム
- `{client.form_sender_name}` ← clientシート `form_sender_name` カラム
- `{client.last_name}` ← clientシート `last_name` カラム
- `{client.first_name}` ← clientシート `first_name` カラム
- `{client.last_name_kana}` ← clientシート `last_name_kana` カラム
- `{client.first_name_kana}` ← clientシート `first_name_kana` カラム
- `{client.last_name_hiragana}` ← clientシート `last_name_hiragana` カラム
- `{client.first_name_hiragana}` ← clientシート `first_name_hiragana` カラム
- `{client.position}` ← clientシート `position` カラム
- `{client.department}` ← clientシート `department` カラム
- `{client.gender}` ← clientシート `gender` カラム
- `{client.email_1}` ← clientシート `email_1` カラム
- `{client.email_2}` ← clientシート `email_2` カラム
- `{client.website_url}` ← clientシート `website_url` カラム
- `{client.postal_code_1}` ← clientシート `postal_code_1` カラム
- `{client.postal_code_2}` ← clientシート `postal_code_2` カラム
- `{client.address_1}` ← clientシート `address_1` カラム
- `{client.address_2}` ← clientシート `address_2` カラム
- `{client.address_3}` ← clientシート `address_3` カラム
- `{client.address_4}` ← clientシート `address_4` カラム
- `{client.address_5}` ← clientシート `address_5` カラム
- `{client.phone_1}` ← clientシート `phone_1` カラム
- `{client.phone_2}` ← clientシート `phone_2` カラム
- `{client.phone_3}` ← clientシート `phone_3` カラム

**ターゲティング情報の対応**（targetingシートから取得）:
- `{targeting.subject}` ← targetingシート `subject` カラム
- `{targeting.message}` ← targetingシート `message` カラム


### 1.4. 処理対象企業抽出アルゴリズム

#### **1.4.1. 大量取得 + 一時ファイル管理方式**

処理対象企業の抽出は、パフォーマンス向上のため大量取得して一時ファイルに保存し、そこから順次処理する方式を採用します。

**最適化されたSQL構築パターン**:
```sql
SELECT c.id, c.name, c.form_url, c.instruction_json, c.instruction_valid
FROM companies c
LEFT JOIN submissions s ON (s.company_id = c.id AND s.status = 'success' AND s.targeting_id = :targeting_id)
WHERE c.form_url IS NOT NULL
  AND [client_config['targeting_sql']の条件]
  AND c.name !~ :ng_companies_pattern
  AND c.instruction_json IS NOT NULL
  AND (c.instruction_valid IS NULL OR c.instruction_valid = true)
  AND s.company_id IS NULL
LIMIT 1000
```

**処理フロー**:
1. **初回大量取得**: ワークフロー開始時に最大1000件の処理対象企業を取得
2. **一時ファイル保存**: 取得した企業情報をJSON形式で一時ファイルに保存
3. **順次処理**: ファイルから10件ずつ読み込んで処理実行
4. **残件管理**: 一時ファイルの残件数が0件になったら再クエリ実行
5. **再取得**: 新しい処理対象がある場合は追加取得して一時ファイルに追記

#### **1.4.2. ng_companies除外処理**

スプレッドシートの `ng_companies` カラムに送信回避すべき企業名がカンマ区切りで格納されています。

**除外処理アルゴリズム**:
1. **データ取得**: client_configの `ng_companies` 値を取得（例: `株式会社A,合同会社B,○○商事`）
2. **null/空文字チェック**: nullまたは空文字の場合は除外処理をスキップ
3. **区切り文字変換**: カンマ（`,`）をパイプ（`|`）に置換して正規表現パターンを作成
4. **SQL組み込み**: `companies.name !~ 'パターン'`としてWHERE句に追加（PostgreSQL正規表現演算子を使用）

**処理例**:
```sql
-- client_config['ng_companies'] = "株式会社A,合同会社B"の場合  
WHERE companies.name !~ '株式会社A|合同会社B'
```

**エラーハンドリング**:
- **無効な正規表現**: SQLエラー発生時はプロセス全体を終了。誤って送信しないようにする。
- **空文字・null**: 除外処理をスキップして正常処理を継続

#### **1.4.3. 品質管理による除外処理**

送信品質の維持とシステム効率化のため、以下の条件の企業を処理対象から除外します。

**指示書無効による除外対象**:`companies.instruction_valid = false`
- 過去の送信で指示書の不備により失敗した企業
- フォーム構造の変更等により現在の指示書では送信できない企業

**NULL値の取り扱い**:
- `instruction_valid = NULL`: 未検証状態として処理対象に含める
- 明示的に`false`が設定された場合のみ判定に使用

**除外による効果**:
- 送信成功率の向上
- システムリソースの効率的利用
- 無駄な処理時間の削減

#### **1.4.4. 送信済み企業重複回避システム**

同一ターゲティング設定での重複送信を防ぐため、大量取得時に送信成功済み企業を一括除外します。

**LEFT JOIN による高速除外**:
```sql
LEFT JOIN submissions s ON (s.company_id = c.id AND s.status = 'success' AND s.targeting_id = :targeting_id)
WHERE s.company_id IS NULL  -- 送信済みでない企業のみ取得
```

### 1.5. GAS側制御システム

#### **1.5.1. スプレッドシート連携による制御システム**

**制御概要**: GASがスプレッドシート専用で動作し、アクティブな targeting-id について定期的に GitHub Actions ワークフローを `repository_dispatch` でトリガー。Supabaseには一切アクセスせず、すべての設定データをスプレッドシートから取得してGitHub Actionsに渡す。

**スプレッドシート構成**: 詳細なスプレッドシート構成については1.3.1節のスプレッドシート構成例を参照。

**制御フロー**:
1. **定期実行**: 1日2回（7時台・13時台）の定期トリガー
2. **アクティブターゲティング確認**: targetingシートで `active=TRUE` のレコードを検索
3. **各アクティブターゲティングに対して個別に以下を実行**:
   - targetingシートから該当レコードの全データを取得
   - `client_id` を使ってclientシートから対応するクライアント情報を取得（project_nameは除外）
   - 両データを結合して完全な設定データを作成（descriptionは除外）
   - **個別ワークフロートリガー**: targeting-id と結合済み設定データを client_payload で `repository_dispatch` を実行し、専用のGitHub Actionsワークフローを起動

#### **1.5.2. 定期実行スケジュール**

**実行タイミング**: 
- **朝の実行**: 7時台（例: 7:00, 7:30など）
- **昼の実行**: 13時台（例: 13:00, 13:30など）
- **頻度**: 1日2回、各 targeting-id について実行

**スケジュール管理**:
- GAS のタイムドリブントリガーで設定
- 各実行時に全アクティブ targeting-id を順次処理
- 必要最小限の実行ログによる処理状況の記録

#### **1.5.3. アクティブ状態制御**

**スプレッドシートチェック**: 
- 各 targeting-id の active カラムを確認
- TRUE の場合のみワークフローをトリガー
- FALSE の場合はスキップ（ログ出力は最小限に抑制）

**エラーハンドリング**:
- スプレッドシート読み込みエラー時の処理
- 無効な targeting-id の検出と除外
- GitHub API エラー時のリトライ処理
- **注意**: Supabase関連のエラーハンドリングは不要（GASはSupabaseにアクセスしない）

### 1.6. 結果記録システム（GitHub Actions専用）

#### **1.6.1. 連続処理結果記録システム**

**概要**: GitHub Actions の `src/form_sender_worker.py` が連続ループ実行結果を10件ごとにSupabaseに直接記録します。GASは結果記録に一切関与しません。

**書き込み方式と処理タイミング**:
- **書き込み方式**: 直接 Supabase に一括書き込み
- **処理タイミング**: 10件の企業の送信処理が完了するたびに一括で実行
- **記録タイミング**: 各ループ完了後、10件の処理が完了するたびに記録

**書き込み対象テーブル**:
1. **`submissions`**: 各送信結果の詳細記録
2. **`companies.instruction_valid`**: 指示書の妥当性フラグ更新

**submissionsテーブル記録項目**:
```sql
INSERT INTO submissions (
  targeting_id,     -- 対応するtargeting.id
  company_id,       -- 対応するcompanies.id
  status,           -- "success" または "failed"
  error_type,       -- エラー分類（失敗時のみ）
  submitted_at      -- 送信日時（JST: 日本標準時）
) VALUES (?, ?, ?, ?, ?)
```

**連続処理での制限管理**: 営業時間制御や送信数上限制御などの詳細な制限管理については2.3.3節を参照。

#### **1.6.2. エラー分類システム**

**主要エラータイプ**:

| エラータイプ | 説明 | 具体例 |
|--------------|------|--------|
| **INSTRUCTION** | 指示書関連エラー | instruction_json不正、必須項目欠損 |
| **ELEMENT** | 要素検出エラー | セレクタ未発見、DOM構造変更 |
| **INPUT** | 入力処理エラー | 値設定失敗、バリデーションエラー |
| **SUBMISSION** | 送信処理エラー | 送信失敗、ネットワークエラー |
| **BOT_DETECTION** | Bot検知システムエラー | reCAPTCHA検出、Cloudflare検出 |
| **TIMEOUT** | タイムアウトエラー | 処理時間超過 |
| **SYSTEM** | システムエラー | データベース接続エラー |

#### **1.6.3. 連続処理ワークフロー出力**

**必要最小限のログ出力**:
- エラー発生時のエラー内容（デバッグ用）
- 終了理由（5時間制限到達、送信数上限到達、処理対象なし、営業時間外など）

**出力制限方針**:
- 統計情報、累計処理数、成功率などの詳細ログは出力しない
- 処理結果の個別ログは最小限に抑制
- GitHub Actionsログの容量を最小化

## 2. 技術実装仕様

### 2.1. GitHub Actions 実行環境仕様

#### **2.1.1. 基本実行環境**

**ランナー環境**: `ubuntu-latest`
**Python バージョン**: 3.11
**処理時間制御**: 詳細な時間制限制御については2.3.2節を参照
**並行実行**: 複数のターゲティングがアクティブな場合、それぞれ独立したワークフローインスタンスが並行実行される（ターゲティング間でのリソース競合なし）
**連続処理**: ワークフロー内で処理対象を10件ずつ抽出・処理するループ実行

**実行環境準備**:
- Python依存関係のインストール
- Playwright Chromiumブラウザの設定
- Linux環境でのブラウザ実行に必要なシステムライブラリの導入

#### **2.1.2. ブラウザ自動化仕様 (GitHub Actions + Playwright)**

**Playwright 設定**:
- **ヘッドレスモード**: GitHub Actions環境では必須
- **セキュリティ設定**: サンドボックス無効化等のCI環境用設定
- **ビューポート**: 1920x1080の標準解像度
- **ユーザーエージェント**: 一般的なChromeブラウザを模倣

**タイムアウト制御**:
- **ページ読み込み**: 15秒
- **要素待機**: 15秒
- **操作実行**: 5秒
- **全体処理**: 5時間制限 (処理継続判定の基準)

### 2.2. 設定管理システム

#### **2.2.1. GitHub Secrets 管理**

**必須環境変数**:
- **`SUPABASE_URL`**: SupabaseプロジェクトURL
- **`SUPABASE_SERVICE_ROLE_KEY`**: Supabaseサービスロールキー

**client_payload パラメータ**:
- **`targeting_id`**: ターゲティング設定ID (GASから送信)
- **`client_config`**: スプレッドシートから取得したクライアント設定データ (JSON形式)

#### **2.2.2. 一時ファイルベース設定取得システム**

**設定取得フロー**:
1. **GASからのデータ送信**: `repository_dispatch`の`client_payload`でJSON設定データを送信
2. **一時ファイル保存**: GitHub Actions内で設定データを一時ファイルに保存
3. **Python側での読み込み**: ファイルパスを引数として渡し、JSON設定を読み込み
4. **セキュリティ**: 処理完了後に一時ファイルを自動削除

**セキュリティ上の利点**:
- 個人情報を含む設定データが環境変数ログに出力されない
- ワークフロー実行履歴に機密情報が残らない
- 一時ファイルは処理完了後に自動削除される

#### **2.2.3. 処理対象企業一時ファイル管理システム**

処理対象企業の抽出と一時ファイル管理の詳細については、1.4.1節の「大量取得+一時ファイル管理方式」を参照してください。

### 2.3. 連続処理ワークフロー制御

#### **2.3.1. 処理ループ制御システム**

**初期化フェーズ**:
1. **大量企業取得**: DBから最大1000件の処理対象企業を取得
2. **一時ファイル作成**: 企業情報をJSON形式で一時ファイルに保存

**メインループ**:
1. **10件取得**: 一時ファイルから次の10件の企業情報を読み込み
2. **バッチ処理**: 取得した企業に対して順次フォーム送信処理
3. **結果記録**: 10件の企業の処理結果をループ完了後に一括でDBに記録
4. **残件チェック**: 一時ファイルの残件数確認
5. **再取得判定**: 残件数0件の場合、新規処理対象をDBから追加取得
6. **制限チェック**: 継続条件（時間、送信数、営業時間）を確認
7. **継続判定**: 条件を満たし処理対象がある場合は次のループへ、そうでなければ終了

#### **2.3.2. 時間制限制御システム**

**5時間制限の実装**:
- **制限設定根拠**: GitHub Actionsワークフローの最大実行時間制限（6時間）を踏まえ、タイムアウトを避けるため5時間で制限を設定し、処理完了の安全マージンを確保
- **開始時刻記録**: ワークフロー開始時にタイムスタンプを記録
- **制限チェック**: 各処理対象取得ループ開始前に経過時間をチェック
- **終了条件**: 開始から5時間経過した場合、新規処理対象取得ループに進まず終了
- **グレースフル終了**: 現在処理中の企業については完了まで実行

#### **2.3.3. 制限管理システム**

**営業時間制御**: 
- 各処理対象取得ループ開始時にJST（日本標準時）での現在時刻とclient_configの営業時間設定を比較
- 営業時間外になった場合は新規処理対象取得ループを開始せず終了

**送信数上限制御**:
- 各企業の送信成功時に当日累計をカウント
- client_config['max_daily_sends'] 設定値に到達した場合は処理を終了

**処理対象枯渇制御**:
- 抽出クエリの結果が0件の場合は正常終了

## 3. 指示書システム

#### **3.1. 指示書（instruction_json）とプレースホルダ変数システム完全仕様**

事前に作成された**指示書（instruction_json）**に基づいて確実な入力を実行します。各企業のフォーム構造は事前に解析済みで、どの要素にどのデータを入力するかが明確に定義されています。プレースホルダ変数の詳細な対応については1.3.2節を参照してください。

**指示書JSONスキーマ仕様**

データベースの`companies.instruction_json`カラムに保存されたJSON指示書の構造：

```json
{
  "form_elements": {
    "任意のキー名": {
      "selector": "string (CSS セレクタ)",
      "input_type": "text | textarea | select | radio | checkbox",
      "required": "boolean (必須項目フラグ)",
      "value": "string (プレースホルダ変数を含む入力値)"
    }
  },
  "submit_button": {
    "selector": "string (送信ボタンのCSSセレクタ)",
    "method": "click"
  }
}
```

**重要な処理ルール**：
指示書の`value`フィールドでは、`{}`で囲まれた部分がプレースホルダ変数として処理されます。プレースホルダ変数の詳細な対応については1.3.2節を参照してください。

#### **指示書の実用例**

**基本的な指示書例**:
```json
{
  "form_elements": {
    "name": {
      "selector": "input[name='name']",
      "input_type": "text",
      "required": true,
      "value": "{client.form_sender_name}"
    },
    "email": {
      "selector": "input[name='email']",
      "input_type": "text",
      "required": true,
      "value": "{client.email_1}@{client.email_2}"
    },
    "message": {
      "selector": "textarea[name='message']",
      "input_type": "textarea",
      "required": true,
      "value": "{targeting.message}"
    }
  },
  "submit_button": {
    "selector": "input[type='submit']",
    "method": "click"
  }
}
```

#### **3.4. 実行フローの概要**

指示書ベース入力は、3つのフェーズで動作します。

#### **フェーズ1: 指示書読み込み・検証**
1. **データベースから指示書取得**: 対象企業の`instruction_json`を読み込み
2. **指示書形式検証**: JSON形式とスキーマの正当性確認
3. **要素存在確認**: 指示書に記載されたセレクタで要素が存在することを確認

#### **フェーズ2: 指示書ベース入力実行**
1. **プレースホルダ変数展開**: `{client.*}`,`{targeting.*}`変数を実際のデータに置換
2. **順次入力処理**: `form_elements`の各項目を順番に処理
3. **入力結果検証**: 各要素への入力が正常に完了したことを確認

#### **フェーズ3: 送信処理**
送信処理フロー（確認ボタン・送信ボタン判定、成功判定）を実行

## 4. フォーム処理アルゴリズム

### 4.1. 事前処理：動的コンテンツの読み込み

多くのモダンなWebサイトでは、ユーザーがスクロールするなどのアクションに応じてコンテンツが動的に読み込まれます。フォームが初期表示時に存在しない場合に備え、以下の事前処理を**最初**に実行します。

#### **基本的なページ読み込み待機**

1. **DOMContentLoaded待機**: 初期DOM構築完了まで待機
2. **window.load待機**: 画像等の基本リソース読み込み完了まで待機（最大15秒）
3. **JavaScript実行完了待機**: setTimeout/setInterval で2秒間待機し、基本的なJavaScript処理の完了を確保

#### **段階的スクロールによる動的読み込み（SPA対応強化）**

**段階的スクロール実行**:
1. **3段階スクロール**: ページを33%→66%→100%の位置まで段階的にスクロール
2. **各段階での待機**: 各スクロール位置で2秒間待機（lazy loading要素の出現を待つ）
3. **フォーム要素の検出**: 各段階でフォーム要素（`<form>`, `<input>`, `<textarea>`）の出現を確認
4. **早期終了**: フォーム要素が検出された時点でスクロール処理を終了

**SPA特有の動的読み込み対応**:

1. **React/Vue等のコンポーネント遅延ローディング**:
   - **IntersectionObserver**: ビューポート内要素の出現を監視
   - **Suspense境界**: React SuspenseやVue Suspenseでの遅延コンポーネント検出
   - **動的import**: `React.lazy()`や`defineAsyncComponent()`での遅延読み込み検出

2. **ルーター遷移の監視**:
   - **History API**: `pushState`/`replaceState`での状態変更監視
   - **Hash変更**: `hashchange`イベントでのルート変更検出
   - **カスタムルーター**: Next.js、Nuxt.js等のフレームワーク固有のルーティング

3. **API データフェッチの待機**:
   - **Network監視**: XMLHttpRequest、fetch API の完了を監視
   - **Promise状態**: 未解決のPromiseの完了待機
   - **Loading状態**: `.loading`, `.spinner`, `[aria-busy="true"]`の消失を確認

4. **仮想化リスト・無限スクロール対応**:
   - **Virtual List**: react-virtualized、vue-virtual-scroller等の検出
   - **Infinite Scroll**: スクロール位置に応じた動的コンテンツ追加の監視
   - **Pagination**: 動的ページネーションでのコンテンツ読み込み

**Lazy Loading対応**:
- `data-src`属性を持つ画像の読み込み完了を5秒間待機
- `loading="lazy"`属性要素のビューポート内表示を確認
- 新規DOM要素の出現を最大3回（各5秒間隔）で監視

#### **タイムアウト設定と処理制限**

**制限時間設定**:

| 処理段階 | タイムアウト時間 | 説明 |
|----------|------------------|------|
| DOM待機 | 15秒 | DOMContentLoaded、window.load待機 |
| スクロール処理 | 15秒 | 段階的スクロール、動的読み込み待機 |
| 事前処理全体 | 30秒 | 上記すべての事前処理の合計制限時間 |
| ページ遷移待機 | 15秒 | 確認ページ遷移時の待機時間 |
| 動的メッセージ監視 | 15秒 | 送信後のMutationObserver監視時間 |

**処理対象の判定**:
- フォーム要素（`<form>`, `<input>`, `<select>`, `<textarea>`, `<button>`）が1つ以上検出された場合に後続処理を実行
- 検出されない場合は「フォーム未検出」として処理を終了

このシンプルな事前処理により、一般的なお問い合わせフォームの動的読み込みに対応しつつ、実装の複雑さを最小限に抑えます。

### 4.2. 指示書ベース入力アルゴリズム

事前に作成された指示書に基づいて、確実にフォーム入力を実行するアルゴリズムです。

#### 4.2.1. 指示書読み込み・検証フェーズ

#### **Step 1: 指示書の取得と解析**
1. **データベースアクセス**: 対象企業の`companies.instruction_json`カラムからJSONデータを取得
2. **JSON解析**: 取得したデータをJavaScriptオブジェクトに変換
3. **基本構造検証**: 指示書の構造とスキーマについては3.1節を参照

#### **Step 2: 要素存在確認（事前検証）**

指示書に記載されたすべてのフォーム要素について、実際にWebページ上に存在することを事前確認します：

1. **全セレクタの存在確認**: 指示書のform_elementsに含まれる各要素のselectorを使用してDOM要素を検索
2. **必須要素の検証**: required=trueの要素が見つからない場合はエラーとして処理を停止
3. **非必須要素の警告**: required=falseの要素が見つからない場合は最小限の警告を出力して処理継続
4. **エラーハンドリング**: 検出失敗時はフォールバック処理またはエラー終了の判定を実行

#### 4.2.2. プレースホルダ変数展開システム

指示書の`value`フィールドに含まれる`{変数名}`形式のプレースホルダを、実際のクライアントデータに置換します。プレースホルダ変数の詳細な対応関係については1.3.2節を参照してください。

#### 4.2.3. 順次入力処理アルゴリズム

#### **基本入力フロー**

指示書の`form_elements`に記載された各要素について、以下の手順で順次入力を実行します：

1. **要素特定**: 指定されたCSSセレクタを使用してDOM要素を検索・取得
2. **値の展開**: プレースホルダ変数を含む`value`フィールドを実際のクライアントデータに展開
3. **入力タイプ別処理**: 要素の種類（text、select、checkbox等）に応じた適切な入力方法を実行
4. **入力結果検証**: 入力した値が正確に設定されているかを確認
5. **完了マーキング**: 処理完了の証跡として要素に`data-instruction-filled="true"`属性を付与

各要素の処理でエラーが発生した場合は、必要最小限のエラー情報を出力してエラーハンドリング処理に移行します。

#### 4.2.4. 入力タイプ別処理詳細

#### **テキスト系入力（text, textarea）**
標準的なテキスト入力フィールドへの入力処理：

1. **フォーカス取得**: 対象要素にフォーカスを当てて入力可能状態に設定
2. **既存値クリア**: 現在の値を空文字でクリアし、inputイベントを発火
3. **新値設定**: 展開済みの値を要素のvalueプロパティに設定
4. **イベント発火**: input・changeイベントを順次発火してJavaScriptの動的処理を実行
5. **フォーカス解除**: blurイベントでフォーカスを外してバリデーション等を実行

#### **選択系入力（select）**
プルダウンメニューやリストボックスでの選択処理：

1. **オプション検索**: 選択肢の中から指定値を含むテキストまたは一致するvalue属性を持つオプションを検索
2. **完全一致優先**: まずvalue属性での完全一致を試行、次にテキスト内容での部分一致を実行
3. **選択実行**: 該当オプションのindexをselectedIndexに設定
4. **イベント発火**: changeイベントを発火して選択変更を通知
5. **エラー処理**: 該当オプションが見つからない場合はエラーを発生

#### **ラジオボタン・チェックボックス**
真偽値や特定値に基づく選択状態の制御：

1. **値の解釈**: 入力値を真偽値として解釈（'true', '1', 要素のvalue値の場合にtrue）
2. **状態判定**: 現在のchecked状態と期待する状態を比較
3. **状態変更**: 必要に応じてcheckedプロパティを更新
4. **イベント発火**: changeイベントを発火して状態変更を他の要素に通知

#### 4.2.5. 入力結果検証システム

#### **基本検証処理**
各入力要素への値設定後、期待値との一致確認を実行：

**テキスト系要素（input, textarea）の検証**:
- 要素のvalueプロパティと期待値の完全一致を確認
- 不一致の場合は期待値と実際の値を含むエラーメッセージを生成

**選択系要素（select）の検証**:
- 選択されたオプションのtextコンテンツが期待値を含んでいるかを確認
- 部分一致で判定し、完全一致でなくても期待値が含まれていれば成功と判定

#### **リアルタイムバリデーション対応**
フォームの動的バリデーション機能との連携：

1. **エラー要素の検出**: フォーム内でエラー状態を示すクラスや属性を持つ要素を検索
2. **エラーメッセージ収集**: `.error`, `.invalid`, `[aria-invalid="true"]`等の要素からテキストを抽出
3. **バリデーション結果の判定**: エラーメッセージの有無で入力値の妥当性を確認

#### 4.2.6. 処理効率最適化

#### **順次処理による確実な入力実行**
シングルワーカーによる順次処理で確実性とデバッグ容易性を重視：

1. **順序制御**: 指示書の定義順序に従った確実な順次入力処理
2. **依存関係管理**: 前項目の入力完了を確認してから次項目に進行
3. **エラー追跡**: 各項目の処理結果を順次確認し、問題箇所を即座に特定
4. **処理安定性**: 単一スレッドでの処理により競合状態やタイミング問題を回避

#### **入力遅延の最適化**
- **即座入力**: 基本的には即座に入力実行
- **遅延入力**: バリデーション処理が重い場合のみ100ms程度の遅延を追加
- **段階的入力**: 依存関係がある項目（住所→郵便番号自動補完等）では適切な順序制御

指示書ベースアルゴリズムにより、確実で安定したフォーム入力を実現します。

### 4.3. 送信処理フロー

指示書ベース入力完了後のフォーム送信から成功判定までの処理フローです。

#### 4.3.1. 送信ボタン特定アルゴリズム

#### **指示書ベース送信ボタン特定**
事前に定義された指示書情報を使用した確実な送信ボタン特定：

1. **指示書からの情報取得**: `submit_button`設定から送信ボタンのセレクタと操作方法を取得
2. **要素検索実行**: 指定されたCSSセレクタを使用してDOM要素を検索
3. **存在確認**: 送信ボタンが見つからない場合はエラーを発生
4. **ボタン種別判定**: 検出されたボタンのテキスト内容で送信ボタン・確認ボタンを判定
   - **確認ボタン**: 「確認」「次」「review」のキーワードを含む場合
   - **送信ボタン**: 「送信」「送る」「完了」「submit」「send」「confirm」のキーワードを含む場合
   - **デフォルト処理**: どちらのキーワードにも該当しない場合は送信ボタンとして扱う

#### 4.3.2. 送信実行処理

#### **直接送信パターン**
確認ページを経由しない直接送信の処理手順：

1. **事前準備**: 送信前のHTML内容とURLを保存（成功判定の比較用）
2. **送信ボタン押下**: 特定済みの送信ボタンをクリック
3. **ネットワーク応答監視**: HTTP通信の完了を待機（リダイレクト・レスポンス確認）
4. **成功判定実行**: 送信前後の状態比較と成功判定アルゴリズムを実行
5. **エラーハンドリング**: 各段階でのエラー発生時の適切な処理（ログ出力は最小限）

#### **確認ページ経由パターン**
確認ページでの確認後に最終送信を行うパターンの処理手順：

1. **確認ボタン押下**: 初期ページの確認ボタンをクリック

2. **ネットワークリクエスト監視**: 確認ボタン押下後のネットワークリクエストの状況に応じて処理を分岐
   - **300番台レスポンスの場合**: リダイレクトが発生したため、ページ読み込みを待機して送信ボタン検出に進む
   - **400・500番台レスポンスの場合**: 確認ページ遷移に失敗したとし、instruction_jsonが原因の送信失敗として処理
   - **200番台レスポンスまたはリクエストなしの場合**: 以下の詳細検証を実行

3. **200番台レスポンス/リクエストなし時の詳細検証**:
   - **想定される状況**: Ajaxで確認ページが表示されているか、入力内容に不備があり確認ページに進めていない
   - **待機処理**: 3秒間待機（リクエストがない場合は押下からの時間、200レスポンスがある場合はレスポンスからの時間）
   - **ページソース確認**: 待機後、ページソースを確認して遷移成功/失敗を判定
   - **確認ボタン同一性チェック**: 直前に押下した確認ボタンと全く同じ要素（submit_buttonでの簡略化されたセレクター指示ではなく、button要素として全く同じもの）の存在を確認
     - **同じボタン要素が存在**: 確認ページへの遷移に失敗したとして、instruction_jsonが原因の送信失敗として処理
     - **同じボタン要素が存在しない**: 確認ページに遷移成功として、最終送信ボタンの検出を行う

4. **最終送信ボタン検出**: 確認ページ内で最終的な送信ボタンを検索
   - **注意**: この段階で送信ボタンが検出できなかった場合は、instruction_jsonが原因ではなく、確認ページでの送信ボタン検出アルゴリズムの問題であるため、instruction_json妥当性記録の対象外

5. **送信ボタン存在確認**: 見つからない場合はエラーとして処理終了

6. **直接送信実行**: 見つかった最終送信ボタンを使用して直接送信パターンを実行

7. **エラー処理**: 各段階でのエラー発生時の必要最小限のエラー処理

#### 4.3.3. 送信成功判定アルゴリズム

#### **3段階判定システム**
以下の優先順位で送信成功可否を判定する仕組み：

1. **段階1：失敗キーワード判定**: ページ内容から送信失敗を示すキーワードを検索（検出されれば即座に失敗）
2. **段階2：成功キーワード判定**: ページ内容から送信成功を示すキーワードを検索（検出されれば成功）  
3. **段階3：HTTPレスポンス判定**: リクエストが発生し300番台レスポンスがあれば成功、それ以外は失敗

#### **段階1：失敗キーワード判定**
送信失敗を明確に示すキーワードの検出（最優先判定）：

**日本語失敗キーワード**: 「送信に失敗」「送信できません」「送信エラー」「エラーが発生」「不正な」「入力してください」
**英語失敗キーワード**: 「submission failed」「error」「invalid」

**検出処理**: ページ全体のテキスト内容を小文字に変換し、各失敗キーワードとの部分一致を確認
**判定ルール**: いずれかの失敗キーワードが検出された場合は即座に失敗と判定

#### **段階2：成功キーワード判定**
送信成功を示すキーワードの検出（失敗キーワードが検出されなかった場合に実行）：

**日本語成功キーワード**: 「送信完了」「送信されました」「ありがとうございます」「受付完了」「お問い合わせを受け付けました」
**英語成功キーワード**: 「thank」「sent」「success」「submitted」

**検出処理**: ページ全体のテキスト内容を小文字に変換し、各成功キーワードとの部分一致を確認
**判定ルール**: いずれかの成功キーワードが検出された場合は成功と判定

#### **段階3：HTTPレスポンス判定**
失敗キーワードも成功キーワードも検出されなかった場合のHTTPレスポンスによる判定：

**判定基準**:
1. **送信ボタン押下後にHTTPリクエストが発生したか確認**
2. **300番台レスポンス（リダイレクト）が発生した場合**: 成功と判定
3. **その他のレスポンス（200番台、400番台、500番台）またはリクエストなし**: 失敗と判定

**処理フロー**:
- 送信ボタン押下後のネットワークアクティビティを監視
- HTTPレスポンスのステータスコードを確認
- 300-399の範囲内であれば成功、それ以外は失敗として最終判定

#### 4.3.4. 動的コンテンツ対応

#### **JavaScript動的メッセージ検出**
送信後に動的に表示されるメッセージの監視と検出：

1. **MutationObserver設定**: DOM変更を監視するオブザーバーを設定
2. **新規要素監視**: childListタイプの変更で新しく追加された要素を検出
3. **成功メッセージ確認**: 新規追加要素内で成功・失敗キーワードを検索
4. **属性変更監視**: class・style属性の変更を監視（要素の表示・非表示切り替え）
5. **監視時間制限**: 15秒間監視後にオブザーバーを自動停止
6. **非同期処理**: Promise形式で監視結果を返却

#### **ポップアップ・モーダル検出**
画面上に表示される各種ポップアップメッセージの検出：

1. **ポップアップ要素検索**: modal、popup、dialog、notification、alert、toast、message-box等のクラス名を持つ要素を検索
2. **表示状態確認**: 検出した要素が実際に画面上で表示されているかを確認
3. **メッセージ抽出**: 表示中のポップアップ要素からテキストコンテンツを抽出
4. **必要時のみ記録**: 検出したポップアップメッセージの内容を必要最小限で記録
5. **結果返却**: 検出されたメッセージテキストを返却、見つからない場合はnullを返却

この送信処理フローにより、指示書ベース入力システムと送信成功判定アルゴリズムを統合し、高精度な送信処理を実現します。

#### 4.3.5. instruction_json妥当性記録システム

指示書（instruction_json）の品質を管理するため、送信処理の結果に基づいて指示書の妥当性を記録するシステムです。

#### **妥当性記録の基本原則**

送信処理の成否に基づいてDBの`companies.instruction_valid`フィールドを更新し、指示書の品質を継続的に管理します。

#### **1. 送信成功時の処理**

**処理内容**: 送信が正常に完了した場合、該当企業レコードの`companies.instruction_valid`を`true`に設定

**対象条件**:
- フォーム入力がすべて正常に完了
- 送信ボタンの特定・押下が成功
- 送信成功判定アルゴリズムで成功と判定された場合

#### **2. instruction_json不備原因での送信失敗時の処理**

**処理内容**: instruction_jsonの指示に従った入力を試行した結果、失敗した場合に`companies.instruction_valid`を`false`に設定

**対象となる失敗ケース**:

1. **フォーム要素の検出失敗**:
   - `form_elements`で指定された要素が見つからない
   - なんらかの項目に入力ができず、その後送信が失敗した場合
   - 注意: 送信が成功した場合は、入力できなかった項目があっても問題なし

2. **送信ボタンの検出失敗**:
   - `submit_button`で指定されたボタンが見つからない
   - フォールバック検索でもボタンを特定できず、送信が失敗した場合

3. **送信失敗**:
   - instruction_jsonに従って入力・送信ボタンのお押下を行った結果、送信失敗と判定された場合（ただし、下記の対象外のケースを除く）

#### **3. instruction_valid書き換えの対象外ケース**

以下の場合は指示書の問題ではないため、`instruction_valid`の書き換えを行わない:

**ユーザー・システム要因による失敗**:
- ユーザーによる処理中断
- ネットワークエラー

**Bot検知システムによる失敗**:
- reCAPTCHA、Cloudflare等のbot検知システムによるブロック
- Bot検知システムの検出は指示書の問題ではないため、対象外

**確認ページ遷移後の失敗**:
- 確認ページに正常に遷移したが、確認ページでの送信ボタン探索や押下に失敗
- 確認ページ内での処理はinstruction_jsonに基づくものではないため、対象外

#### **4. 処理実装の要件**

**事前取得**: 
- instruction_jsonを取得する際に、現在の`instruction_valid`値も同時に取得
- 送信処理後に書き換えの必要性を判定

**DB操作の実装**:
- 書き換えが必要でない場合（値が同じ場合）は、DB書き込み処理をスキップ
- 不要なDB操作を避けることで処理の安定性を向上

#### 4.3.6. Bot検知システム対応

reCAPTCHAやCloudflareなどのbot送信防止システムを検知し、適切に処理するためのシステムです。

#### **Bot検知システムの概要**

**対応対象システム**:
- **reCAPTCHA**: Googleのbot検知システム（v2, v3対応）
- **Cloudflare**: Cloudflare Bot Managementシステム
- **その他汎用bot検知**: 一般的な認証チャレンジやJavaScript検証

#### **検知方法と判定基準**

**1. DOM要素による検知**:
- `iframe[src*="recaptcha"]` - reCAPTCHA v2の検知
- `.cf-browser-verification` - Cloudflare検証ページの検知
- `[data-sitekey]` - reCAPTCHA要素の検知
- `.g-recaptcha` - reCAPTCHA埋め込み要素の検知

**2. URL パターンによる検知**:
- `/cdn-cgi/challenge-platform/` - Cloudflare チャレンジの検知
- `google.com/recaptcha/` - reCAPTCHAリソースの検知

**3. テキスト内容による検知**:
- "Checking your browser" - Cloudflare検証メッセージ
- "Please verify you are human" - 一般的なbot検証メッセージ
- "Just a moment" - Cloudflare待機メッセージ

#### **Bot検知時の処理フロー**

**1. 検知処理の実行タイミング**:
- フォーム送信ボタン押下後
- ページ読み込み完了時
- JavaScript実行待機中

**2. 検知時の処理**:
```
1. Bot検知システムを特定（reCAPTCHA/Cloudflare/その他）
2. 送信処理を中止
3. エラー情報を記録：
   - submissions.error_type = "BOT_DETECTION"
   - submissions.status = "failed"
4. 企業データの更新：
   - companies.instruction_valid = 変更なし（指示書の問題ではないため）
```

