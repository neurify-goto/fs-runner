## はじめに

このドキュメントでは、**RuleBasedAnalyzer による動的フォーム解析**に基づいて、Webサイトのお問い合わせフォームに対し、指定されたデータを入力送信するための、**GAS トリガー + GitHub Actions ワークフロー**による自動化システムの網羅的なアルゴリズムを自然言語で記述します。

**実行アーキテクチャ（最新版）**: Google Apps Script (GAS) が毎朝 Supabase に当日分の送信キュー（`send_queue`）を直接生成し、その後 `repository_dispatch` で GitHub Actions を起動します。GitHub Actions はエントリ `src/form_sender_runner.py` を実行し、Runner 内の各ワーカーが Supabase RPC（`claim_next_batch`）でキューを原子的に専有→フォーム送信→結果を `mark_done` で確定・保存します。営業時間・日次成功上限制御は Runner 側で継続的に判定します。設計の詳細は `docs/form_sender_plan.md` を一次参照としてください。

あくまで処理フローを自然言語で定義する文書であるため、システム要件や実装計画、運用方針等については基本的に記述しません。

## 関連ファイル（最新版）
- **ワークフロー**: `.github/workflows/form-sender.yml`
- **実行ファイル**: `src/form_sender_runner.py`
- **GAS制御システム**: `gas/form-sender/Code.gs`, `gas/form-sender/SpreadsheetClient.gs`, `gas/form-sender/GitHubClient.gs`
  - （Supabase直呼び出し）`gas/form-sender/SupabaseClient.gs`

## 1. システム概要と実行仕様

GAS トリガー + GitHub Actions ワークフローによるフォーム送信システムの実行方法、データベース構成、および制御システムの仕様について説明します。

### 1.1. 実行アーキテクチャ仕様

#### **1.1.1. システム全体構成**

**GAS制御システム** → **GitHub Actions ワークフロー**

**トリガーフロー**:
1. **GAS定期実行**: 毎日決まった時間帯に起動
2. **アクティブ判定**: targeting-id ごとのアクティブ状態を確認
3. **repository_dispatch**: アクティブな targeting-id とスプレッドシート設定データを GitHub Actions ワークフローにトリガー
4. **連続ループ実行**: 営業時間等の制限を判定した上で、実行可能かどうかを判定した上で、ワークフロー内で処理対象を10件ずつ抽出・処理
5. **結果記録**: GitHub Actions内で各処理ループごとに Supabase に結果を直接保存

#### **1.1.2. GitHub Actions ワークフロー仕様（更新）**

- **ワークフローファイル**: `.github/workflows/form-sender.yml`
- **トリガータイプ**: `repository_dispatch` (イベントタイプ: `form_sender_task`)
- **実行ファイル**: `src/form_sender_runner.py`

**処理単位**: 1つのワークフロー実行につき1つのターゲティング設定を処理（複数のターゲティングがアクティブな場合は、それぞれ独立したワークフローが並行実行される）

**client_payload パラメータ**:
- `targeting_id`: ターゲティング設定ID（1以上の整数、必須）
- `client_config`: スプレッドシートから取得したクライアント設定データ（JSON形式、GASから渡される）

**実行環境**:
- **OS**: ubuntu-latest
- **Python**: 3.11
- **処理時間制御**: 開始から5時間経過で新規処理停止
- **ブラウザ**: Playwright Chromium

**連続処理仕様（更新）**:
- **処理単位**: `send_queue` から RPC `claim_next_batch(..., limit=1)` で1件ずつ原子的専有
- **ループ制御**: 営業時間（`send_days_of_week`, `send_start_time`, `send_end_time`）と日次成功上限（`max_daily_sends`）を Runner がJST基準で判定
- **バックオフ**: キュー枯渇時は指数バックオフ（最大60秒、ジッターあり）
- **終了条件**: キュー枯渇の継続／日次成功上限到達／ワークフロータイムアウト（`timeout-minutes`）

### 1.2. データベース構成仕様（更新）

本システムは「当日用ワークキュー」として `send_queue` を中心に運用します（毎朝リセット）。詳細は `docs/form_sender_plan.md` の「3. Supabase 設計」を参照してください。

主要要素:
- `send_queue` テーブル（当日分のみ、毎朝リセット）
- RPC: `reset_send_queue_all`, `create_queue_for_targeting`, `claim_next_batch`, `mark_done`, `requeue_stale_assigned`
- `submissions` テーブル（送信結果; `submitted_at` はJSTで保存）

#### **1.2.1. スプレッドシート `client`シート（GAS担当）**

**役割**: フォーム営業代行サービスのクライアント情報とターゲティング設定を管理
- **フォーム入力用情報**: 送信者情報、企業情報、連絡先等

**データアクセスパターン**:
- **読み取り**: GASがスプレッドシートから設定を読み取り、GitHub Actionsに渡す
- **管理**: 手動でのスプレッドシート編集による設定変更
- **書き込み**: GASおよびGitHub Actionsの処理フロー内では書き込みなし

#### **1.2.2. スプレッドシート `targeting`シート（GAS担当）**

**役割**: フォーム営業代行サービスのクライアント情報とターゲティング設定を管理
- **フォーム送信制御情報情報**: 送信対象抽出条件、制限設定、営業時間等
- **アクティブ状態管理**: targeting-id ごとの有効/無効制御

**データアクセスパターン**:
- **読み取り**: GASがスプレッドシートから設定を読み取り、GitHub Actionsに渡す
- **管理**: 手動でのスプレッドシート編集による設定変更
- **書き込み**: GASおよびGitHub Actionsの処理フロー内では書き込みなし

#### **1.2.3. Supabase `companies`テーブル（GitHub Actions担当）**

**役割**: フォーム送信先企業の個別情報を管理
- 企業基本情報（社名、フォームURL等）
- 営業禁止フラグ（prohibition_detected）

**データアクセスパターン**:
- **読み取り**: GitHub Actionsが処理対象企業の抽出
- **書き込み**: GitHub Actionsが`prohibition_detected`フラグの更新（営業禁止文言検出時のみ）

#### **1.2.4. Supabase `submissions`テーブル（GitHub Actions担当）**

**役割**: フォーム送信結果の履歴管理
- 送信成功・失敗の記録
- エラー分類とトラッキング
- 重複送信回避のための履歴

**データアクセスパターン**:
- **書き込み**: GitHub Actionsが送信結果の記録（成功・失敗両方）
- **読み取り**: GitHub Actionsが重複送信回避、日次送信数カウント

#### **1.2.5. DBアクセス機構**

**アーキテクチャ分離によるDBアクセス**: GitHub Actions が Supabase にアクセス。GAS は Supabase に一切アクセスせず、スプレッドシートの読み取りと GitHub Actions のトリガーのみを担当。

**連続処理でのDB アクセス考慮事項**:
- **処理時間制御**: 5時間制限を考慮した長時間安定接続の維持
- **リソース管理**: 長時間実行による接続プールの効率的管理と定期的な接続チェック
- **トランザクション制御**: 10件ごとの処理結果をまとめてコミットし、処理効率と障害時の影響範囲を最適化
- **接続安定性**: 長時間実行中のDB接続断絶に対する自動再接続とリトライ機構

### 1.3. クライアントデータ取得システム

#### **1.3.1. アクティブターゲティング向けスプレッドシートデータ抽出フロー**

GAS定期実行時に、targetingシートのアクティブ状態（`active=TRUE`）に基づいて、該当するクライアントデータを取得します。

**データ取得の流れ**:
1. **スプレッドシート接続**: GAS側でスプレッドシートに接続
2. **アクティブターゲティング検索**: targetingシートで `active=TRUE` のレコードをすべて検索
3. **各アクティブレコードに対して個別に以下を実行**:
   - **client_id取得**: 該当のtargetingレコードからclient_idを取得
   - **クライアントデータ取得**: clientシートからclient_idに対応するクライアント情報を取得
   - **データ結合**: targetingデータとclientデータを結合（project_nameは除外）
   - **個別ワークフロートリガー**: 1つのtargeting用に独立した `repository_dispatch` を実行し、専用のGitHub Actionsワークフローを起動

**スプレッドシート構成例**:

**targetingシート**:
| active | id | client_id | description | subject | message | targeting_sql | ng_companies | max_daily_sends | send_start_time | send_end_time | send_days_of_week |
|--------|----|-----------|-----------|---------|---------|--------------|--------------|-----------------|-----------------|--------------|--------------------|
| TRUE | 1 | 1 | IT企業向け新規営業 | お問い合わせの件 | お世話になっております。... | WHERE... | 除外企業リスト | 100 | 09:00 | 18:00 | [0,1,2,3,4] |

**clientシート**:
| id | project_name | company_name | company_name_kana | form_sender_name | last_name | first_name | last_name_kana | first_name_kana | last_name_hiragana | first_name_hiragana | position | department | gender | email_1 | email_2 | website_url | postal_code_1 | postal_code_2 | address_1 | address_2 | address_3 | address_4 | address_5 | phone_1 | phone_2 | phone_3 |
|----|--------------|--------------|-------------------|------------------|-----------|------------|----------------|-----------------|--------------------|--------------------|----------|------------|--------|---------|---------|-------------|---------------|---------------|-----------|-----------|-----------|-----------|-----------|---------|---------|---------|
| 1 | サンプルプロジェクト | 株式会社サンプル | カブシキガイシャサンプル | 田中太郎 | 田中 | 太郎 | タナカ | タロウ | たなか | たろう | 営業部長 | 営業部 | male | tanaka | sample.com | https://sample.co.jp | 100 | 0001 | 東京都 | 千代田区 | 神田 | 1-1-1 | サンプルビル5F | 03 | 1234 | 5678 |

#### **1.3.2. 動的フィールドマッピングとの連携**

取得したスプレッドシートデータは、RuleBasedAnalyzerの動的解析で使用されるクライアントデータ変数に対応します。

**クライアントデータ構造リファレンス**：

RuleBasedAnalyzerが動的マッピング時に参照するクライアントデータ構造：

**client情報**（clientシートから取得）:
- company_name: 企業名
- company_name_kana: 企業名カナ
- form_sender_name: 送信者名
- last_name / first_name: 姓名（漢字）
- last_name_kana / first_name_kana: 姓名（カタカナ）
- last_name_hiragana / first_name_hiragana: 姓名（ひらがな）
- position / department: 役職/部署
- gender: 性別
- email_1 / email_2: メールアドレス部分
- website_url: ウェブサイトURL
- postal_code_1 / postal_code_2: 郵便番号部分
- address_1~5: 住所部分
- phone_1~3: 電話番号部分

**targeting情報**（targetingシートから取得）:
- subject: 件名
- message: メッセージ内容


### 1.4. 送信キュー（send_queue）運用（新方式）

処理対象企業の抽出・整列は GAS → Supabase の RPC で実施し、当日用の `send_queue` に投入します。

- `reset_send_queue_all()`（06:25 JST）で当日用キューを完全リセット
- `create_queue_for_targeting(targeting_id, targeting_sql, ng_companies, ...)`（06:35–06:50 JST）で各ターゲティングの候補を抽出・整列・分割投入（上限5,000件/targeting）
- Runner は `claim_next_batch(..., limit=1)` で1件ずつ原子的に専有し、処理結果を `mark_done(...)` で記録

`targeting_sql` は WHERE 断片として扱い、GAS 側・サーバ側（関数内）で最低限の危険句を拒否します。送信済み成功分は `submissions.success=true` を参照して自動除外されます。

### 1.5. GAS側制御システム

#### **1.5.1. スプレッドシート連携による制御システム**

**制御概要**: GASがスプレッドシート専用で動作し、アクティブな targeting-id について定期的に GitHub Actions ワークフローを `repository_dispatch` でトリガー。Supabaseには一切アクセスせず、すべての設定データをスプレッドシートから取得してGitHub Actionsに渡す。

**スプレッドシート構成**: 詳細なスプレッドシート構成については1.3.1節のスプレッドシート構成例を参照。

**制御フロー**:
1. **定期実行**: 1日2回（7時台・13時台）の定期トリガー
2. **アクティブターゲティング確認**: targetingシートで `active=TRUE` のレコードを検索
3. **各アクティブターゲティングに対して個別に以下を実行**:
   - targetingシートから該当レコードの全データを取得
   - `client_id` を使ってclientシートから対応するクライアント情報を取得（project_nameは除外）
   - 両データを結合して完全な設定データを作成（descriptionは除外）
   - **個別ワークフロートリガー**: targeting-id と結合済み設定データを client_payload で `repository_dispatch` を実行し、専用のGitHub Actionsワークフローを起動

#### **1.5.2. 定期実行スケジュール**

**実行タイミング**: 
- **朝の実行**: 7時台（例: 7:00, 7:30など）
- **昼の実行**: 13時台（例: 13:00, 13:30など）
- **頻度**: 1日2回、各 targeting-id について実行

**スケジュール管理**:
- GAS のタイムドリブントリガーで設定
- 各実行時に全アクティブ targeting-id を順次処理
- 必要最小限の実行ログによる処理状況の記録

#### **1.5.3. アクティブ状態制御**

**スプレッドシートチェック**: 
- 各 targeting-id の active カラムを確認
- TRUE の場合のみワークフローをトリガー
- FALSE の場合はスキップ（ログ出力は最小限に抑制）

**エラーハンドリング**:
- スプレッドシート読み込みエラー時の処理
- 無効な targeting-id の検出と除外
- GitHub API エラー時のリトライ処理
- **注意**: Supabase関連のエラーハンドリングは不要（GASはSupabaseにアクセスしない）

### 1.6. 結果記録システム（GitHub Actions専用）

#### **1.6.1. 連続処理結果記録システム**

**概要**: GitHub Actions の `src/form_sender_worker.py` が連続ループ実行結果を10件ごとにSupabaseに直接記録します。GASは結果記録に一切関与しません。

**書き込み方式と処理タイミング**:
- **書き込み方式**: 直接 Supabase に一括書き込み
- **処理タイミング**: 10件の企業の送信処理が完了するたびに一括で実行
- **記録タイミング**: 各ループ完了後、10件の処理が完了するたびに記録

**書き込み対象テーブル**:
1. **`submissions`**: 各送信結果の詳細記録
2. **`companies.prohibition_detected`**: 営業禁止フラグ更新（陽性時のみ）

**submissionsテーブル記録項目**:
```sql
INSERT INTO submissions (
  targeting_id,     -- 対応するtargeting.id
  company_id,       -- 対応するcompanies.id
  status,           -- "success" または "failed" または "skipped"（実装上は success:boolean を使用）
  error_type,       -- エラー分類（失敗時のみ）
  classify_detail,  -- JSONB: { code, category, retryable, cooldown_seconds, confidence }
  submitted_at      -- 送信日時（JST: 日本標準時）
) VALUES (?, ?, ?, ?, ?, ?)
```

**連続処理での制限管理**: 営業時間制御や送信数上限制御などの詳細な制限管理については2.3.3節を参照。

#### **1.6.2. エラー分類システム**

**主要エラータイプ**:

| エラータイプ | 説明 | 具体例 |
|--------------|------|--------|
| **ANALYSIS** | フォーム解析エラー | 動的解析失敗、フォーム構造不明 |
| **ELEMENT** | 要素検出エラー | セレクタ未発見、DOM構造変更 |
| **INPUT** | 入力処理エラー | 値設定失敗、バリデーションエラー |
| **SUBMISSION** | 送信処理エラー | 送信失敗、ネットワークエラー |
| **BOT_DETECTION** | Bot検知システムエラー | reCAPTCHA検出、Cloudflare検出 |
| **PROHIBITION** | 営業禁止検出 | 営業目的送信禁止文言の検出 |
| **TIMEOUT** | タイムアウトエラー | 処理時間超過 |
| **SYSTEM** | システムエラー | データベース接続エラー |

#### **1.6.3. 連続処理ワークフロー出力**

**必要最小限のログ出力**:
- エラー発生時のエラー内容（デバッグ用）
- 終了理由（5時間制限到達、送信数上限到達、処理対象なし、営業時間外など）

**出力制限方針**:
- 統計情報、累計処理数、成功率などの詳細ログは出力しない
- 処理結果の個別ログは最小限に抑制
- GitHub Actionsログの容量を最小化

## 2. 技術実装仕様

### 2.1. GitHub Actions 実行環境仕様

#### **2.1.1. 基本実行環境**

**ランナー環境**: `ubuntu-latest`
**Python バージョン**: 3.11
**処理時間制御**: 詳細な時間制限制御については2.3.2節を参照
**並行実行**: 複数のターゲティングがアクティブな場合、それぞれ独立したワークフローインスタンスが並行実行される（ターゲティング間でのリソース競合なし）
**連続処理**: ワークフロー内で処理対象を10件ずつ抽出・処理するループ実行

**実行環境準備**:
- Python依存関係のインストール
- Playwright Chromiumブラウザの設定
- Linux環境でのブラウザ実行に必要なシステムライブラリの導入

#### **2.1.2. ブラウザ自動化仕様 (GitHub Actions + Playwright)**

**Playwright 設定**:
- **ヘッドレスモード**: GitHub Actions環境では必須
- **セキュリティ設定**: サンドボックス無効化等のCI環境用設定
- **ビューポート**: 1920x1080の標準解像度
- **ユーザーエージェント**: 一般的なChromeブラウザを模倣

**タイムアウト制御**:
- **ページ読み込み**: 15秒
- **要素待機**: 15秒
- **操作実行**: 5秒
- **全体処理**: 5時間制限 (処理継続判定の基準)

### 2.2. 設定管理システム

#### **2.2.1. GitHub Secrets 管理**

**必須環境変数**:
- **`SUPABASE_URL`**: SupabaseプロジェクトURL
- **`SUPABASE_SERVICE_ROLE_KEY`**: Supabaseサービスロールキー

**client_payload パラメータ**:
- **`targeting_id`**: ターゲティング設定ID (GASから送信)
- **`client_config`**: スプレッドシートから取得したクライアント設定データ (JSON形式)

#### **2.2.2. 一時ファイルベース設定取得システム**

**設定取得フロー**:
1. **GASからのデータ送信**: `repository_dispatch`の`client_payload`でJSON設定データを送信
2. **一時ファイル保存**: GitHub Actions内で設定データを一時ファイルに保存
3. **Python側での読み込み**: ファイルパスを引数として渡し、JSON設定を読み込み
4. **セキュリティ**: 処理完了後に一時ファイルを自動削除

**セキュリティ上の利点**:
- 個人情報を含む設定データが環境変数ログに出力されない
- ワークフロー実行履歴に機密情報が残らない
- 一時ファイルは処理完了後に自動削除される

#### **2.2.3. 処理対象企業一時ファイル管理システム**

処理対象企業の抽出と一時ファイル管理の詳細については、1.4.1節の「大量取得+一時ファイル管理方式」を参照してください。

### 2.3. 連続処理ワークフロー制御

#### **2.3.1. 処理ループ制御システム**

**初期化フェーズ**:
1. **大量企業取得**: DBから最大1000件の処理対象企業を取得
2. **一時ファイル作成**: 企業情報をJSON形式で一時ファイルに保存

**メインループ**:
1. **10件取得**: 一時ファイルから次の10件の企業情報を読み込み
2. **バッチ処理**: 取得した企業に対して順次フォーム送信処理
3. **結果記録**: 10件の企業の処理結果をループ完了後に一括でDBに記録
4. **残件チェック**: 一時ファイルの残件数確認
5. **再取得判定**: 残件数0件の場合、新規処理対象をDBから追加取得
6. **制限チェック**: 継続条件（時間、送信数、営業時間）を確認
7. **継続判定**: 条件を満たし処理対象がある場合は次のループへ、そうでなければ終了

#### **2.3.2. 時間制限制御システム**

**5時間制限の実装**:
- **制限設定根拠**: GitHub Actionsワークフローの最大実行時間制限（6時間）を踏まえ、タイムアウトを避けるため5時間で制限を設定し、処理完了の安全マージンを確保
- **開始時刻記録**: ワークフロー開始時にタイムスタンプを記録
- **制限チェック**: 各処理対象取得ループ開始前に経過時間をチェック
- **終了条件**: 開始から5時間経過した場合、新規処理対象取得ループに進まず終了
- **グレースフル終了**: 現在処理中の企業については完了まで実行

#### **2.3.3. 制限管理システム**

**営業時間制御**: 
- 各処理対象取得ループ開始時にJST（日本標準時）での現在時刻とclient_configの営業時間設定を比較
- 営業時間外になった場合は新規処理対象取得ループを開始せず終了

**送信数上限制御**:
- 各企業の送信成功時に当日累計をカウント
- client_config['max_daily_sends'] 設定値に到達した場合は処理を終了

**処理対象枯渇制御**:
- 抽出クエリの結果が0件の場合は正常終了

## 3. 動的フォーム解析システム

#### **3.1. RuleBasedAnalyzer による動的解析システム**

**RuleBasedAnalyzer**を使用してリアルタイムでフォーム構造を解析し、クライアントデータに基づいて動的に入力を実行します。事前の指示書作成は不要で、フォーム構造の変更にも柔軟に対応できます。

**動的解析の主要機能**:
- フォーム要素の自動検出と分類
- フィールドタイプの自動判定（テキスト、選択、チェックボックス等）
- コンテキスト情報を利用した高精度なフィールドマッピング
- 分割フィールド（姓名、郵便番号等）の自動結合処理
- プレースホルダ変数によるクライアントデータの動的挿入

#### **3.2. 動的フィールドマッピングシステム**

RuleBasedAnalyzerが生成するinput_assignmentsにより、動的解析で特定されたフィールドに対してクライアント設定データから適切な値を自動的に割り当てます。フィールドマッピングの詳細な対応については1.3.2節を参照してください。

#### **3.3. 営業禁止文言検出システム**

フォーム解析の前段階で、ページ内容から営業目的の問い合わせを禁止する文言を検出します。

**検出対象文言**:
- 「営業目的のお問い合わせはご遠慮ください」
- 「営業・勧誘はお断り」
- 「商品・サービスの売り込みはお控えください」
- その他営業活動を明確に禁止する表現

**検出時の処理**:
1. フォーム解析・入力処理を中断
2. `companies.prohibition_detected = true` を記録
3. `submissions` に `status = "skipped"`, `error_type = "PROHIBITION"` を記録
4. 処理を正常終了

#### **3.4. 実行フローの概要**

動的解析ベース入力は、以下の4つのフェーズで動作します。

#### **フェーズ1: 営業禁止文言検出**
1. **ページ内容解析**: フォームページの全体テキストを取得
2. **禁止文言検索**: 営業目的送信を禁止する文言の有無を確認
3. **早期終了判定**: 禁止文言が検出された場合は送信処理を中断

#### **フェーズ2: 動的フォーム解析**
1. **フォーム構造解析**: RuleBasedAnalyzerによるフォーム要素の自動検出
2. **フィールドマッピング**: コンテキスト情報を利用した高精度な項目対応
3. **入力値生成**: RuleBasedAnalyzerのinput_assignmentsによる動的値生成

#### **フェーズ3: 動的入力実行**
1. **順次入力処理**: 解析結果に基づく各フィールドへの自動入力
2. **入力結果検証**: 各要素への入力が正常に完了したことを確認
3. **分割フィールド処理**: 姓名、郵便番号等の分割フィールドの適切な結合

#### **フェーズ4: 送信処理**
送信処理フロー（確認ボタン・送信ボタン判定、成功判定）を実行

## 4. フォーム処理アルゴリズム

### 4.1. 事前処理：動的コンテンツの読み込み

多くのモダンなWebサイトでは、ユーザーがスクロールするなどのアクションに応じてコンテンツが動的に読み込まれます。フォームが初期表示時に存在しない場合に備え、以下の事前処理を**最初**に実行します。

#### **基本的なページ読み込み待機**

1. **DOMContentLoaded待機**: 初期DOM構築完了まで待機
2. **window.load待機**: 画像等の基本リソース読み込み完了まで待機（最大15秒）
3. **JavaScript実行完了待機**: setTimeout/setInterval で2秒間待機し、基本的なJavaScript処理の完了を確保

#### **段階的スクロールによる動的読み込み（SPA対応強化）**

**段階的スクロール実行**:
1. **3段階スクロール**: ページを33%→66%→100%の位置まで段階的にスクロール
2. **各段階での待機**: 各スクロール位置で2秒間待機（lazy loading要素の出現を待つ）
3. **フォーム要素の検出**: 各段階でフォーム要素（`<form>`, `<input>`, `<textarea>`）の出現を確認
4. **早期終了**: フォーム要素が検出された時点でスクロール処理を終了

**SPA特有の動的読み込み対応**:

1. **React/Vue等のコンポーネント遅延ローディング**:
   - **IntersectionObserver**: ビューポート内要素の出現を監視
   - **Suspense境界**: React SuspenseやVue Suspenseでの遅延コンポーネント検出
   - **動的import**: `React.lazy()`や`defineAsyncComponent()`での遅延読み込み検出

2. **ルーター遷移の監視**:
   - **History API**: `pushState`/`replaceState`での状態変更監視
   - **Hash変更**: `hashchange`イベントでのルート変更検出
   - **カスタムルーター**: Next.js、Nuxt.js等のフレームワーク固有のルーティング

3. **API データフェッチの待機**:
   - **Network監視**: XMLHttpRequest、fetch API の完了を監視
   - **Promise状態**: 未解決のPromiseの完了待機
   - **Loading状態**: `.loading`, `.spinner`, `[aria-busy="true"]`の消失を確認

4. **仮想化リスト・無限スクロール対応**:
   - **Virtual List**: react-virtualized、vue-virtual-scroller等の検出
   - **Infinite Scroll**: スクロール位置に応じた動的コンテンツ追加の監視
   - **Pagination**: 動的ページネーションでのコンテンツ読み込み

**Lazy Loading対応**:
- `data-src`属性を持つ画像の読み込み完了を5秒間待機
- `loading="lazy"`属性要素のビューポート内表示を確認
- 新規DOM要素の出現を最大3回（各5秒間隔）で監視

#### **タイムアウト設定と処理制限**

**制限時間設定**:

| 処理段階 | タイムアウト時間 | 説明 |
|----------|------------------|------|
| DOM待機 | 15秒 | DOMContentLoaded、window.load待機 |
| スクロール処理 | 15秒 | 段階的スクロール、動的読み込み待機 |
| 事前処理全体 | 30秒 | 上記すべての事前処理の合計制限時間 |
| ページ遷移待機 | 15秒 | 確認ページ遷移時の待機時間 |
| 動的メッセージ監視 | 15秒 | 送信後のMutationObserver監視時間 |

**処理対象の判定**:
- フォーム要素（`<form>`, `<input>`, `<select>`, `<textarea>`, `<button>`）が1つ以上検出された場合に後続処理を実行
- 検出されない場合は「フォーム未検出」として処理を終了

このシンプルな事前処理により、一般的なお問い合わせフォームの動的読み込みに対応しつつ、実装の複雑さを最小限に抑えます。

### 4.2. 動的解析ベース入力アルゴリズム

RuleBasedAnalyzerによる動的解析結果に基づいて、フォーム入力を実行するアルゴリズムです。

#### 4.2.1. 営業禁止文言検出フェーズ

#### **Step 1: ページ内容の取得と解析**
1. **ページテキスト取得**: フォームページの全体テキストコンテンツを抽出
2. **禁止文言検索**: 営業目的送信を禁止する文言パターンとの照合
3. **検出結果判定**: 禁止文言が検出された場合は送信処理を中断

#### **Step 2: 禁止検出時の処理**

営業禁止文言が検出された場合の処理手順：

1. **データベース記録**: `companies.prohibition_detected = true` を記録
2. **送信履歴記録**: `submissions`テーブルに `status = "skipped"`, `error_type = "PROHIBITION"` を記録
3. **処理終了**: フォーム解析・入力処理をスキップして正常終了

#### 4.2.2. 動的フォーム解析フェーズ

#### **Step 1: RuleBasedAnalyzer実行**
1. **フォーム構造解析**: ページ内のフォーム要素を自動検出・分類
2. **フィールドマッピング**: コンテキスト情報を利用した高精度な項目対応
3. **解析結果検証**: 必須フィールドの検出確認とマッピング品質評価
4. **エラーハンドリング**: 解析失敗時は適切なエラー分類で処理終了

#### 4.2.3. 動的フィールドマッピングシステム

RuleBasedAnalyzerが生成したinput_assignmentsに基づいて、各フィールドに対してクライアントデータから適切な値を動的に割り当てます。フィールドマッピングの詳細な対応関係については1.3.2節を参照してください。

#### 4.2.4. 順次入力処理アルゴリズム

#### **基本入力フロー**

RuleBasedAnalyzerの解析結果に記載された各要素について、以下の手順で順次入力を実行します：

1. **要素特定**: 解析結果のセレクタを使用してDOM要素を検索・取得
2. **値の割り当て**: input_assignmentsで指定された値を各フィールドに割り当て
3. **入力タイプ別処理**: 要素の種類（text、select、checkbox等）に応じた適切な入力方法を実行
4. **入力結果検証**: 入力した値が正確に設定されているかを確認
5. **完了マーキング**: 処理完了の証跡として要素に`data-analysis-filled="true"`属性を付与

各要素の処理でエラーが発生した場合は、必要最小限のエラー情報を出力してエラーハンドリング処理に移行します。

#### 4.2.4. 入力タイプ別処理詳細

#### **テキスト系入力（text, textarea）**
標準的なテキスト入力フィールドへの入力処理：

1. **フォーカス取得**: 対象要素にフォーカスを当てて入力可能状態に設定
2. **既存値クリア**: 現在の値を空文字でクリアし、inputイベントを発火
3. **新値設定**: 展開済みの値を要素のvalueプロパティに設定
4. **イベント発火**: input・changeイベントを順次発火してJavaScriptの動的処理を実行
5. **フォーカス解除**: blurイベントでフォーカスを外してバリデーション等を実行

#### **選択系入力（select）**
プルダウンメニューやリストボックスでの選択処理：

1. **オプション検索**: 選択肢の中から指定値を含むテキストまたは一致するvalue属性を持つオプションを検索
2. **完全一致優先**: まずvalue属性での完全一致を試行、次にテキスト内容での部分一致を実行
3. **選択実行**: 該当オプションのindexをselectedIndexに設定
4. **イベント発火**: changeイベントを発火して選択変更を通知
5. **エラー処理**: 該当オプションが見つからない場合はエラーを発生

#### **ラジオボタン・チェックボックス**
真偽値や特定値に基づく選択状態の制御：

1. **値の解釈**: 入力値を真偽値として解釈（'true', '1', 要素のvalue値の場合にtrue）
2. **状態判定**: 現在のchecked状態と期待する状態を比較
3. **状態変更**: 必要に応じてcheckedプロパティを更新
4. **イベント発火**: changeイベントを発火して状態変更を他の要素に通知

#### 4.2.5. 入力結果検証システム

#### **基本検証処理**
各入力要素への値設定後、期待値との一致確認を実行：

**テキスト系要素（input, textarea）の検証**:
- 要素のvalueプロパティと期待値の完全一致を確認
- 不一致の場合は期待値と実際の値を含むエラーメッセージを生成

**選択系要素（select）の検証**:
- 選択されたオプションのtextコンテンツが期待値を含んでいるかを確認
- 部分一致で判定し、完全一致でなくても期待値が含まれていれば成功と判定

#### **リアルタイムバリデーション対応**
フォームの動的バリデーション機能との連携：

1. **エラー要素の検出**: フォーム内でエラー状態を示すクラスや属性を持つ要素を検索
2. **エラーメッセージ収集**: `.error`, `.invalid`, `[aria-invalid="true"]`等の要素からテキストを抽出
3. **バリデーション結果の判定**: エラーメッセージの有無で入力値の妥当性を確認

#### 4.2.6. 処理効率最適化

#### **順次処理による確実な入力実行**
シングルワーカーによる順次処理で確実性とデバッグ容易性を重視：

1. **順序制御**: 指示書の定義順序に従った確実な順次入力処理
2. **依存関係管理**: 前項目の入力完了を確認してから次項目に進行
3. **エラー追跡**: 各項目の処理結果を順次確認し、問題箇所を即座に特定
4. **処理安定性**: 単一スレッドでの処理により競合状態やタイミング問題を回避

#### **入力遅延の最適化**
- **即座入力**: 基本的には即座に入力実行
- **遅延入力**: バリデーション処理が重い場合のみ100ms程度の遅延を追加
- **段階的入力**: 依存関係がある項目（住所→郵便番号自動補完等）では適切な順序制御

動的解析ベースアルゴリズムにより、フォーム構造の変更に対応した確実で安定したフォーム入力を実現します。

### 4.3. 送信処理フロー

指示書ベース入力完了後のフォーム送信から成功判定までの処理フローです。

#### 4.3.1. 送信ボタン特定アルゴリズム

#### **動的解析ベース送信ボタン特定**
RuleBasedAnalyzerの解析結果を使用した確実な送信ボタン特定：

1. **解析結果からの情報取得**: 動的解析で検出された送信ボタン情報を取得
2. **要素検索実行**: 解析結果のセレクタを使用してDOM要素を検索
3. **存在確認**: 送信ボタンが見つからない場合はフォールバック検索を実行
4. **ボタン種別判定**: 検出されたボタンのテキスト内容で送信ボタン・確認ボタンを判定
   - **確認ボタン**: 「確認」「次」「review」のキーワードを含む場合
   - **送信ボタン**: 「送信」「送る」「完了」「submit」「send」「confirm」のキーワードを含む場合
   - **デフォルト処理**: どちらのキーワードにも該当しない場合は送信ボタンとして扱う

#### 4.3.2. 送信実行処理

#### **直接送信パターン**
確認ページを経由しない直接送信の処理手順：

1. **事前準備**: 送信前のHTML内容とURLを保存（成功判定の比較用）
2. **送信ボタン押下**: 特定済みの送信ボタンをクリック
3. **ネットワーク応答監視**: HTTP通信の完了を待機（リダイレクト・レスポンス確認）
4. **成功判定実行**: 送信前後の状態比較と成功判定アルゴリズムを実行
5. **エラーハンドリング**: 各段階でのエラー発生時の適切な処理（ログ出力は最小限）

#### **確認ページ経由パターン**
確認ページでの確認後に最終送信を行うパターンの処理手順：

1. **確認ボタン押下**: 初期ページの確認ボタンをクリック

2. **ネットワークリクエスト監視**: 確認ボタン押下後のネットワークリクエストの状況に応じて処理を分岐
   - **300番台レスポンスの場合**: リダイレクトが発生したため、ページ読み込みを待機して送信ボタン検出に進む
   - **400・500番台レスポンスの場合**: 確認ページ遷移に失敗したとし、動的解析が原因の送信失敗として処理
   - **200番台レスポンスまたはリクエストなしの場合**: 以下の詳細検証を実行

3. **200番台レスポンス/リクエストなし時の詳細検証**:
   - **想定される状況**: Ajaxで確認ページが表示されているか、入力内容に不備があり確認ページに進めていない
   - **待機処理**: 3秒間待機（リクエストがない場合は押下からの時間、200レスポンスがある場合はレスポンスからの時間）
   - **ページソース確認**: 待機後、ページソースを確認して遷移成功/失敗を判定
   - **確認ボタン同一性チェック**: 直前に押下した確認ボタンと全く同じ要素の存在を確認
     - **同じボタン要素が存在**: 確認ページへの遷移に失敗したとして、動的解析が原因の送信失敗として処理
     - **同じボタン要素が存在しない**: 確認ページに遷移成功として、最終送信ボタンの検出を行う

4. **最終送信ボタン検出**: 確認ページ内で最終的な送信ボタンを検索
   - **注意**: この段階で送信ボタンが検出できなかった場合は、動的解析が原因ではなく、確認ページでの送信ボタン検出アルゴリズムの問題であるため、記録対象外

5. **送信ボタン存在確認**: 見つからない場合はエラーとして処理終了

6. **直接送信実行**: 見つかった最終送信ボタンを使用して直接送信パターンを実行

7. **エラー処理**: 各段階でのエラー発生時の必要最小限のエラー処理

#### 4.3.3. 送信成功判定アルゴリズム

#### **実装上の優先ルール（早期失敗ゲート + 6段階判定）**
以下の順で判定します。早期失敗ゲートでヒットした場合は即失敗とします。

0. **早期失敗ゲート（最優先）**
   - **Bot保護検知**: reCAPTCHA/Cloudflare などが表示されていれば失敗
   - **失敗メッセージ/エラー要素**: 「入力してください」「未入力」「必須」「正しく入力してください」「エラー」等の文言、もしくは `.error`, `.invalid`, `[aria-invalid="true"]`, `[role="alert"]` 等のエラー要素が可視なら失敗
1. **URL変更判定**: 成功指標を含むパスへの遷移や別ドメインへの遷移を成功候補とみなす（後述のガードを必ず実施）
   - 注意: **クエリ/ハッシュのみの変更は成功とみなさない**（誤判定抑制）
   - URL変更で成功候補になっても、その直後に再度 Bot/エラーメッセージのガード検査を行い、検出された場合は失敗に倒す
2. **成功メッセージ判定**: 本文・代表的要素から成功メッセージを検出
3. **フォーム消失判定**: フォームが消えた、または要素数が大幅減少した場合は成功候補
4. **兄弟要素解析判定**: 成功を示す新規要素や無効化状態を検出
5. **エラーパターン判定**: 分類済みのエラーパターンで失敗を判定
6. **失敗パターン判定**: 明確な失敗指標が多い場合に失敗、それ以外は低信頼の成功推定

#### **段階1：失敗キーワード判定**
送信失敗を明確に示すキーワードの検出（最優先判定）：

**日本語失敗キーワード**: 「送信に失敗」「送信できません」「送信エラー」「エラーが発生」「不正な」「入力してください」
**英語失敗キーワード**: 「submission failed」「error」「invalid」

**検出処理**: ページ全体のテキスト内容を小文字に変換し、各失敗キーワードとの部分一致を確認
**判定ルール**: いずれかの失敗キーワードが検出された場合は即座に失敗と判定

#### **段階2：成功キーワード判定**
送信成功を示すキーワードの検出（失敗キーワードが検出されなかった場合に実行）：

**日本語成功キーワード**: 「送信完了」「送信されました」「ありがとうございます」「受付完了」「お問い合わせを受け付けました」
**英語成功キーワード**: 「thank」「sent」「success」「submitted」

**検出処理**: ページ全体のテキスト内容を小文字に変換し、各成功キーワードとの部分一致を確認
**判定ルール**: いずれかの成功キーワードが検出された場合は成功と判定

#### **段階3：HTTPレスポンス判定**
失敗キーワードも成功キーワードも検出されなかった場合のHTTPレスポンスによる判定：

**重要なガード（誤判定抑制）**:
- **URLのクエリ/ハッシュのみの変更は成功とみなさない**
- **URL変更で成功候補になっても、直後にBot/エラーメッセージの再検査を必ず行う**
- **Bot保護（reCAPTCHA/Cloudflare 等）表示時は常に失敗扱い**

#### **実装原則（Single Source of Truth）**
- 最終的な送信成否は常に `src/form_sender/analyzer/success_judge.py` の `SuccessJudge.judge_submission_success()` に集約し、
  他の経路（確認ページ経由・フォールバック）でもこのメソッドの結果を採用する。
  URL変化のみや簡易パターン判定だけで成功にしない。

**処理フロー**:
- 送信ボタン押下後のネットワークアクティビティを監視
- HTTPレスポンスのステータスコードを確認
- 300-399の範囲内であれば成功、それ以外は失敗として最終判定

#### 4.3.4. 動的コンテンツ対応

#### **JavaScript動的メッセージ検出**
送信後に動的に表示されるメッセージの監視と検出：

1. **MutationObserver設定**: DOM変更を監視するオブザーバーを設定
2. **新規要素監視**: childListタイプの変更で新しく追加された要素を検出
3. **成功メッセージ確認**: 新規追加要素内で成功・失敗キーワードを検索
4. **属性変更監視**: class・style属性の変更を監視（要素の表示・非表示切り替え）
5. **監視時間制限**: 15秒間監視後にオブザーバーを自動停止
6. **非同期処理**: Promise形式で監視結果を返却

#### **ポップアップ・モーダル検出**
画面上に表示される各種ポップアップメッセージの検出：

1. **ポップアップ要素検索**: modal、popup、dialog、notification、alert、toast、message-box等のクラス名を持つ要素を検索
2. **表示状態確認**: 検出した要素が実際に画面上で表示されているかを確認
3. **メッセージ抽出**: 表示中のポップアップ要素からテキストコンテンツを抽出
4. **必要時のみ記録**: 検出したポップアップメッセージの内容を必要最小限で記録
5. **結果返却**: 検出されたメッセージテキストを返却、見つからない場合はnullを返却

この送信処理フローにより、指示書ベース入力システムと送信成功判定アルゴリズムを統合し、高精度な送信処理を実現します。

#### 4.3.5. 営業禁止文言記録システム

営業目的の送信を禁止する企業を適切に管理するため、営業禁止文言の検出結果を記録するシステムです。

#### **営業禁止記録の基本原則**

営業禁止文言の検出結果に基づいてDBの`companies.prohibition_detected`フィールドを更新し、適切な送信回避を実現します。

#### **1. 営業禁止文言検出時の処理**

**処理内容**: フォームページで営業禁止文言が検出された場合、該当企業レコードの`companies.prohibition_detected`を`true`に設定

**対象条件**:
- フォームページに営業目的送信を禁止する文言が存在
- 検出文言が営業活動を明確に禁止している

**記録内容**:
- `companies.prohibition_detected = true`
- `submissions.status = "skipped"`
- `submissions.error_type = "PROHIBITION"`

#### **2. 通常送信時の処理**

**処理内容**: 営業禁止文言が検出されず、通常の送信処理を実行した場合

**記録方針**:
- `companies.prohibition_detected`フィールドは更新しない（既存値を保持）
- 営業禁止文言の不存在を積極的に記録する必要はない

#### **3. 処理実装の要件**

**検出タイミング**: 
- フォーム解析の前段階で営業禁止文言検出を実行
- 検出された場合は即座に送信処理を中断

**DB操作の実装**:
- 営業禁止文言が検出された場合のみDB書き込み処理を実行
- 不要なDB操作を避けることで処理の安定性を向上

#### 4.3.6. Bot検知システム対応

reCAPTCHAやCloudflareなどのbot送信防止システムを検知し、適切に処理するためのシステムです。

#### **Bot検知システムの概要**

**対応対象システム**:
- **reCAPTCHA**: Googleのbot検知システム（v2, v3対応）
- **Cloudflare**: Cloudflare Bot Managementシステム
- **その他汎用bot検知**: 一般的な認証チャレンジやJavaScript検証

#### **検知方法と判定基準**

**1. DOM要素による検知**:
- `iframe[src*="recaptcha"]` - reCAPTCHA v2の検知
- `.cf-browser-verification` - Cloudflare検証ページの検知
- `[data-sitekey]` - reCAPTCHA要素の検知
- `.g-recaptcha` - reCAPTCHA埋め込み要素の検知

**2. URL パターンによる検知**:
- `/cdn-cgi/challenge-platform/` - Cloudflare チャレンジの検知
- `google.com/recaptcha/` - reCAPTCHAリソースの検知

**3. テキスト内容による検知**:
- "Checking your browser" - Cloudflare検証メッセージ
- "Please verify you are human" - 一般的なbot検証メッセージ
- "Just a moment" - Cloudflare待機メッセージ

#### **Bot検知時の処理フロー**

**1. 検知処理の実行タイミング**:
- フォーム送信ボタン押下後
- ページ読み込み完了時
- JavaScript実行待機中

**2. 検知時の処理**:
```
1. Bot検知システムを特定（reCAPTCHA/Cloudflare/その他）
2. 送信処理を中止
3. エラー情報を記録：
   - submissions.error_type = "BOT_DETECTION"
   - submissions.status = "failed"
```
